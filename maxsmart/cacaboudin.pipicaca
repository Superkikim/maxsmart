# maxsmart/network.py

import subprocess
import asyncio
import re
import platform
import logging


class NetworkUtils:
    """Network utilities for MAC address discovery and ARP operations."""
    
    @staticmethod
    async def get_mac_from_arp(ip_address, timeout=5.0):
        """
        Get MAC address from ARP table for a given IP address.
        
        Args:
            ip_address (str): IP address to look up
            timeout (float): Timeout for operations in seconds
            
        Returns:
            str or None: MAC address in format "XX:XX:XX:XX:XX:XX" or None if not found
        """
        # Try multiple methods in order of preference
        methods = [
            NetworkUtils._try_getmac_library,
            NetworkUtils._try_nmap_scan,
            NetworkUtils._try_native_arp,
        ]
        
        for method in methods:
            try:
                mac = await method(ip_address, timeout)
                if mac and NetworkUtils.is_valid_mac_address(mac):
                    logging.debug(f"Found MAC {mac} for {ip_address} using {method.__name__}")
                    return NetworkUtils._normalize_mac_address(mac)
            except Exception as e:
                logging.debug(f"Method {method.__name__} failed for {ip_address}: {e}")
                continue
        
        logging.debug(f"All MAC discovery methods failed for {ip_address}")
        return None
    
    @staticmethod
    async def _try_getmac_library(ip_address, timeout):
        """Try using getmac library."""
        try:
            # Try importing getmac
            from getmac import get_mac_address
            
            # Run in executor to avoid blocking
            loop = asyncio.get_event_loop()
            mac = await asyncio.wait_for(
                loop.run_in_executor(None, get_mac_address, ip_address),
                timeout=timeout
            )
            
            return mac
            
        except ImportError:
            # getmac not installed
            raise Exception("getmac library not available")
        except Exception as e:
            raise Exception(f"getmac failed: {e}")
    
    @staticmethod
    async def _try_nmap_scan(ip_address, timeout):
        """Try using nmap for MAC discovery."""
        try:
            # Check if nmap is available
            nmap_cmd = ["nmap", "-sn", "-T4", ip_address]
            
            process = await asyncio.create_subprocess_exec(
                *nmap_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(), timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                raise Exception("nmap timeout")
            
            if process.returncode == 0:
                output = stdout.decode('utf-8', errors='ignore')
                # Look for MAC address in nmap output
                # Format: "MAC Address: XX:XX:XX:XX:XX:XX (Vendor)"
                mac_match = re.search(r'MAC Address: ([0-9A-Fa-f:]{17})', output)
                if mac_match:
                    return mac_match.group(1)
            
            raise Exception("No MAC found in nmap output")
            
        except FileNotFoundError:
            raise Exception("nmap not available")
        except Exception as e:
            raise Exception(f"nmap failed: {e}")
    
    @staticmethod
    async def _try_native_arp(ip_address, timeout):
        """Try native ARP table approach."""
        try:
            # First, ensure the device is in ARP table by pinging it
            await NetworkUtils._ensure_arp_entry(ip_address, timeout / 2)
            
            # Then query ARP table
            mac_address = await NetworkUtils._query_arp_table(ip_address, timeout / 2)
            
            if mac_address:
                return mac_address
            else:
                raise Exception("No MAC found in ARP table")
                
        except Exception as e:
            raise Exception(f"Native ARP failed: {e}")
    
    @staticmethod
    async def _ensure_arp_entry(ip_address, timeout):
        """
        Ensure the IP is in ARP table by pinging it.
        
        Args:
            ip_address (str): IP address to ping
            timeout (float): Timeout for ping operation
        """
        try:
            system = platform.system().lower()
            
            if system == "windows":
                cmd = ["ping", "-n", "1", "-w", str(int(timeout * 1000)), ip_address]
            elif system == "darwin":  # macOS
                cmd = ["ping", "-c", "1", "-W", str(int(timeout * 1000)), ip_address]
            else:
                # Linux, etc.
                cmd = ["ping", "-c", "1", "-W", str(int(timeout)), ip_address]
            
            # Run ping to populate ARP table
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                await asyncio.wait_for(process.communicate(), timeout=timeout)
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                
        except Exception as e:
            logging.debug(f"Ping failed for {ip_address}: {e}")
            # Not critical - ARP entry might already exist
    
    @staticmethod
    async def _query_arp_table(ip_address, timeout):
        """
        Query ARP table for MAC address of given IP.
        
        Args:
            ip_address (str): IP address to look up
            timeout (float): Timeout for ARP query
            
        Returns:
            str or None: Raw MAC address string or None
        """
        try:
            system = platform.system().lower()
            
            if system == "windows":
                cmd = ["arp", "-a", ip_address]
            elif system == "darwin":  # macOS
                # Try both formats
                cmd = ["arp", "-n", ip_address]
            else:
                # Linux, etc.
                cmd = ["arp", "-n", ip_address]
            
            # Run ARP command
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(
                    process.communicate(), timeout=timeout
                )
            except asyncio.TimeoutError:
                process.kill()
                await process.wait()
                return None
            
            if process.returncode == 0:
                output = stdout.decode('utf-8', errors='ignore')
                return NetworkUtils._parse_arp_output(output, ip_address, system)
            else:
                # Try alternative command on macOS
                if system == "darwin":
                    try:
                        cmd_alt = ["arp", "-a", ip_address]
                        process_alt = await asyncio.create_subprocess_exec(
                            *cmd_alt,
                            stdout=asyncio.subprocess.PIPE,
                            stderr=asyncio.subprocess.PIPE
                        )
                        stdout_alt, _ = await asyncio.wait_for(
                            process_alt.communicate(), timeout=timeout
                        )
                        if process_alt.returncode == 0:
                            output_alt = stdout_alt.decode('utf-8', errors='ignore')
                            return NetworkUtils._parse_arp_output(output_alt, ip_address, system)
                    except:
                        pass
                
                logging.debug(f"ARP command failed for {ip_address}: {stderr.decode()}")
                return None
                
        except Exception as e:
            logging.debug(f"ARP query failed for {ip_address}: {e}")
            return None
    
    @staticmethod
    def _parse_arp_output(output, ip_address, system):
        """
        Parse ARP command output to extract MAC address.
        
        Args:
            output (str): ARP command output
            ip_address (str): Target IP address
            system (str): Operating system name
            
        Returns:
            str or None: MAC address string or None
        """
        try:
            if system == "windows":
                # Windows ARP output format:
                # Internet Address      Physical Address      Type
                # 192.168.1.1          aa-bb-cc-dd-ee-ff     dynamic
                
                for line in output.split('\n'):
                    if ip_address in line:
                        # Look for MAC address pattern with hyphens
                        mac_match = re.search(r'([0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2}-[0-9a-fA-F]{2})', line)
                        if mac_match:
                            return mac_match.group(1)
            elif system == "darwin":  # macOS
                # macOS ARP output formats:
                # Format 1: "hostname (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0 ifscope [ethernet]"
                # Format 2: "192.168.1.1 (192.168.1.1) at aa:bb:cc:dd:ee:ff on en0 ifscope [ethernet]"
                
                for line in output.split('\n'):
                    if ip_address in line:
                        # Look for MAC address pattern with colons
                        mac_match = re.search(r'at ([0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2})', line)
                        if mac_match:
                            return mac_match.group(1)
            else:
                # Linux ARP output format:
                # 192.168.1.1 ether aa:bb:cc:dd:ee:ff C eth0
                
                for line in output.split('\n'):
                    if ip_address in line:
                        # Look for MAC address pattern with colons
                        mac_match = re.search(r'([0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2}:[0-9a-fA-F]{2})', line)
                        if mac_match:
                            return mac_match.group(1)
            
            return None
            
        except Exception as e:
            logging.debug(f"Failed to parse ARP output: {e}")
            return None
    
    @staticmethod
    def _normalize_mac_address(mac_address):
        """
        Normalize MAC address to standard format XX:XX:XX:XX:XX:XX.
        
        Args:
            mac_address (str): MAC address in various formats
            
        Returns:
            str: Normalized MAC address
        """
        if not mac_address:
            return None
            
        # Remove all non-hex characters and convert to uppercase
        hex_only = re.sub(r'[^0-9a-fA-F]', '', mac_address).upper()
        
        # Validate length
        if len(hex_only) != 12:
            return None
            
        # Format as XX:XX:XX:XX:XX:XX
        return ':'.join(hex_only[i:i+2] for i in range(0, 12, 2))
    
    @staticmethod
    def is_valid_mac_address(mac_address):
        """
        Validate MAC address format.
        
        Args:
            mac_address (str): MAC address to validate
            
        Returns:
            bool: True if valid MAC address format
        """
        if not mac_address:
            return False
            
        # Check for standard format XX:XX:XX:XX:XX:XX or XX-XX-XX-XX-XX-XX
        pattern = r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$'
    
    @staticmethod
    async def test_arp_functionality():
        """
        Test ARP functionality by querying common gateway addresses.
        
        Returns:
            dict: Test results with success status and details
        """
        test_results = {
            "arp_available": False,
            "ping_available": False,
            "system": platform.system(),
            "methods_tested": [],
            "test_ips": []
        }
        
        # Common gateway IPs to test
        test_ips = ["192.168.1.1", "192.168.0.1", "10.0.0.1", "172.30.47.1"]
        
        for ip in test_ips:
            try:
                mac = await NetworkUtils.get_mac_from_arp(ip, timeout=3.0)
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": mac,
                    "success": mac is not None
                })
                
                if mac:
                    test_results["arp_available"] = True
                    test_results["ping_available"] = True
                    
            except Exception as e:
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": None,
                    "success": False,
                    "error": str(e)
                })
        
        # Test method availability
        try:
            from getmac import get_mac_address
            test_results["methods_tested"].append("getmac_library")
        except ImportError:
            pass
            
        # Test nmap availability
        try:
            process = await asyncio.create_subprocess_exec(
                "nmap", "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await process.communicate()
            if process.returncode == 0:
                test_results["methods_tested"].append("nmap_scan")
        except:
            pass
            
        test_results["methods_tested"].append("native_arp")
        
        return test_results
        return bool(re.match(pattern, mac_address))
    
    @staticmethod
    async def test_arp_functionality():
        """
        Test ARP functionality by querying common gateway addresses.
        
        Returns:
            dict: Test results with success status and details
        """
        test_results = {
            "arp_available": False,
            "ping_available": False,
            "system": platform.system(),
            "methods_tested": [],
            "test_ips": []
        }
        
        # Common gateway IPs to test
        test_ips = ["192.168.1.1", "192.168.0.1", "10.0.0.1", "172.30.47.1"]
        
        for ip in test_ips:
            try:
                mac = await NetworkUtils.get_mac_from_arp(ip, timeout=3.0)
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": mac,
                    "success": mac is not None
                })
                
                if mac:
                    test_results["arp_available"] = True
                    test_results["ping_available"] = True
                    
            except Exception as e:
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": None,
                    "success": False,
                    "error": str(e)
                })
        
        # Test method availability
        try:
            from getmac import get_mac_address
            test_results["methods_tested"].append("getmac_library")
        except ImportError:
            pass
            
        # Test nmap availability
        try:
            process = await asyncio.create_subprocess_exec(
                "nmap", "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await process.communicate()
            if process.returncode == 0:
                test_results["methods_tested"].append("nmap_scan")
        except:
            pass
            
        test_results["methods_tested"].append("native_arp")
        
        return test_results
    
    @staticmethod
    async def test_arp_functionality():
        """
        Test ARP functionality by querying common gateway addresses.
        
        Returns:
            dict: Test results with success status and details
        """
        test_results = {
            "arp_available": False,
            "ping_available": False,
            "system": platform.system(),
            "methods_tested": [],
            "test_ips": []
        }
        
        # Common gateway IPs to test
        test_ips = ["192.168.1.1", "192.168.0.1", "10.0.0.1", "172.30.47.1"]
        
        for ip in test_ips:
            try:
                mac = await NetworkUtils.get_mac_from_arp(ip, timeout=3.0)
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": mac,
                    "success": mac is not None
                })
                
                if mac:
                    test_results["arp_available"] = True
                    test_results["ping_available"] = True
                    
            except Exception as e:
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": None,
                    "success": False,
                    "error": str(e)
                })
        
        # Test method availability
        try:
            from getmac import get_mac_address
            test_results["methods_tested"].append("getmac_library")
        except ImportError:
            pass
            
        # Test nmap availability
        try:
            process = await asyncio.create_subprocess_exec(
                "nmap", "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await process.communicate()
            if process.returncode == 0:
                test_results["methods_tested"].append("nmap_scan")
        except:
            pass
            
        test_results["methods_tested"].append("native_arp")
        
        return test_results
        return bool(re.match(pattern, mac_address))
    
    @staticmethod
    async def test_arp_functionality():
        """
        Test ARP functionality by querying common gateway addresses.
        
        Returns:
            dict: Test results with success status and details
        """
        test_results = {
            "arp_available": False,
            "ping_available": False,
            "system": platform.system(),
            "methods_tested": [],
            "test_ips": []
        }
        
        # Common gateway IPs to test
        test_ips = ["192.168.1.1", "192.168.0.1", "10.0.0.1", "172.30.47.1"]
        
        for ip in test_ips:
            try:
                mac = await NetworkUtils.get_mac_from_arp(ip, timeout=3.0)
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": mac,
                    "success": mac is not None
                })
                
                if mac:
                    test_results["arp_available"] = True
                    test_results["ping_available"] = True
                    
            except Exception as e:
                test_results["test_ips"].append({
                    "ip": ip,
                    "mac": None,
                    "success": False,
                    "error": str(e)
                })
        
        # Test method availability
        try:
            from getmac import get_mac_address
            test_results["methods_tested"].append("getmac_library")
        except ImportError:
            pass
            
        # Test nmap availability
        try:
            process = await asyncio.create_subprocess_exec(
                "nmap", "--version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await process.communicate()
            if process.returncode == 0:
                test_results["methods_tested"].append("nmap_scan")
        except:
            pass
            
        test_results["methods_tested"].append("native_arp")
        
        return test_results